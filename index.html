<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>did:pqie Method Specification v1.0.0</title>
    <style>
        :root {
            --w3c-blue: #005A9C;
            --w3c-red: #DA121A;
            --text: #1a1a1a;
            --bg: #fff;
            --border: #ddd;
            --code-bg: #f6f8fa;
        }

        body {
            font-family: "Georgia", serif;
            color: var(--text);
            background: var(--bg);
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem 1.5rem 4rem;
            line-height: 1.7;
        }

        header {
            border-top: 6px solid var(--w3c-blue);
            padding: 1.5rem 0 1rem;
            margin-bottom: 2rem;
        }

        header h1 {
            font-size: 2rem;
            color: var(--w3c-blue);
            font-family: sans-serif;
            margin-bottom: .4rem;
        }

        h2 {
            font-size: 1.4rem;
            color: var(--w3c-blue);
            font-family: sans-serif;
            margin: 2rem 0 .6rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: .3rem;
        }

        h3 {
            font-size: 1.1rem;
            color: #333;
            font-family: sans-serif;
            margin: 1.5rem 0 .4rem;
        }

        code {
            font-family: "SFMono-Regular", Consolas, monospace;
            font-size: .875em;
            background: var(--code-bg);
            padding: 1px 5px;
            border-radius: 3px;
            border: 1px solid var(--border);
        }

        pre {
            background: var(--code-bg);
            padding: 1rem;
            border: 1px solid var(--border);
            border-radius: 6px;
            overflow-x: auto;
            margin: .8rem 0;
            font-family: "SFMono-Regular", Consolas, monospace;
            font-size: .85rem;
            line-height: 1.5;
        }

        .meta {
            font-size: .9rem;
            color: #555;
            font-family: sans-serif;
        }
    </style>
</head>

<body>

    <header>
        <h1>did:pqie Method Specification</h1>
        <div class="meta">
            <span><strong>Version:</strong> 1.0.0</span> |
            <span><strong>Published:</strong> 2026-02-26</span> |
            <span><strong>Authors:</strong> PQIE Research Group</span> |
            <span><strong>Support:</strong> <a href="mailto:dixadholakiya@gmail.com">dixadholakiya@gmail.com</a></span>
        </div>
    </header>

    <section>
    <h2>Abstract</h2>
    <p>This paper introduces Post-Quantum Identity Encryption (PQIE), a fully lattice-based security layer for Decentralized Identifiers (DIDs) that encrypts entire DID Documents with Ring-Learning-With-Errors (Ring-LWE) and applies a built-in homomorphic noise filter. The framework is blockchain-agnostic: encrypted identities (or their hashes) can be stored on any key-value ledgers. PQIE is positioned at the intersection of post-quantum cryptography and self-sovereign identity. Where traditional DID methods focus on substituting elliptic-curve keys with lattice signatures, our approach re-thinks the entire trust pipeline—from key material to on-chain storage—by insisting that no part of the DID Document ever travels or rests in plaintext.</p>
</section>
<section>
    <h2>1. Introduction</h2>
    <p>Digital identity is rapidly shifting from centralized systems to distributed systems, where users control their own credentials. The W3C Decentralized Identifier (DID) specification decouples identifiers from centralized registries by anchoring them in distributed ledgers. Yet most DID methods still rely on elliptic-curve cryptography—susceptible to quantum attacks. Blockchain provides an immutable substrate for storing identity proofs, but quantum readiness remains an open gap.</p>
    <p>Blockchains introduce an append-only ledger where every state transition is cryptographically attested. This immutability is attractive to identity systems because it eliminates single points of compromise. However, the transparency of public chains also magnifies privacy risk: metadata correlation attacks can reveal social graphs or user-credential relationships.</p>
    <p>Self-Sovereign Identity (SSI) combines DIDs and Verifiable Credentials (VCs) to give individuals agency over how their data are shared. Creating a quantum-resistant SSI stack requires post-quantum key generation, end-to-end encryption, and efficient noise management. PQIE addresses these needs while remaining ledger-independent.</p>
</section>
<section>
        <h2>About</h2>
        <p>PQIE - is a common method for identities that rely on the implementation of the Post-Quantum Identity
            Encryption (PQIE) framework. The framework is compatible with any key-value ledger and focuses on ensuring
            maximum privacy and quantum-resistance using Ring-Learning-With-Errors (Ring-LWE) cryptography.</p>
    </section>

    <section>
    <h2>2. PQIE Framework</h2>
    <p>PQIE’s strategy of encrypting the entire DID Document mitigates this leakage while retaining auditability via on-chain hash pointers.</p>
    <p>From an economic perspective the cost of on-chain bytes matters. Lattice ciphertexts can be bulky, but our homomorphic filtering keeps the encrypted DID payload below 2 kB, which costs low over blockchain operations.</p>
    <table border="1" cellpadding="5" cellspacing="0" style="margin-top: 1rem; border-collapse: collapse; font-size: 0.9rem;">
        <tr><th>Block</th><th>What it does</th><th>Minimal implementation detail</th></tr>
        <tr><td><strong>O:User Interface</strong></td><td>Captures identity data and initiates “Create DID”.</td><td>Web form / mobile app sends JSON to a back-end endpoint.</td></tr>
        <tr><td><strong>A:Ring-LWE Key Generator</strong></td><td>Produces quantum-safe key pair (pk, sk).</td><td>• n = 512<br>• q ≈ 24 577<br>• σ ≈ 4.0</td></tr>
        <tr><td><strong>A:DID Derivation</strong></td><td>Converts pk into a standards-compliant DID string.</td><td>did:pqie: + base58( SHA-256(pk)[:16] ).</td></tr>
        <tr><td><strong>A:DID Document Builder</strong></td><td>Assembles JSON-LD doc containing: DID, verification keys, services.</td><td>Embed pk under verificationMethod[0].</td></tr>
        <tr><td><strong>A:PQIE Encryptor</strong></td><td>Encrypts the entire DID Document with Ring-LWE KEM.</td><td>1. Generate ephemeral lattice key<br>2. Derive shared secret SS = KEM(pk)<br>3. AES-GCM(SS, DID-JSON) ⇒ ciphertext C.</td></tr>
        <tr><td><strong>B:Homomorphic Noise Filter</strong></td><td>Keeps lattice noise small over long sessions.</td><td>compute cᵢ’ = (cᵢ mod q/4); set new modulus q←q/4.</td></tr>
        <tr><td><strong>B:Post-Quantum Signature</strong></td><td>Signs ciphertext so verifiers know it came from the controller.</td><td>Use PQIE Ring-LWE signature, Attach signature.</td></tr>
        <tr><td><strong>E:Ledger Writer</strong></td><td>Stores ciphertext on any blockchain.</td><td>Either as transaction or as pointer</td></tr>
        <tr><td><strong>F:Resolver Plug-in</strong></td><td>Retrieves, decrypts, and verifies.</td><td>Fetch on-chain payload P.<br>Decapsulate and Decrypt clear_doc.<br>Signature Verify.<br>Return plaintext DID.</td></tr>
    </table>
    <br>
    
    <h3>2.1 End-to-End Flow</h3>
    <p>This diagram shows how a fully quantum-safe digital identity is created, stored, and verified using PQIE and Hyperledger Indy. When someone wants a new DID, they start with their personal details and use a special Ring-LWE algorithm to make a key pair. That DID string is then encrypted into a single blob (ciphertext) and noise is filtered out so the encrypted data stays small and fast. This encrypted DID is placed on a ledger. Later, if anyone needs to look up that DID, they fetch the encrypted blob, use the matching public key to decrypt it, and reveal the real DID.</p>
    
    <h3>2.2 Key Pair Generation</h3>
    <ul>
        <li><strong>E (Input Data)</strong>: The plaintext data is first lifted into the polynomial ring.</li>
        <li><strong>Quantum Security: Ring-LWE Trapdoor Hardness</strong>: Recovering the secret polynomial s from a single “a·s + e” sample is as hard as the Shortest Vector Problem in a family of cyclotomic lattices.</li>
        <li><strong>Apply Number-Theoretic Transform (NTT)</strong>: Converts the polynomial coefficients into the “NTT domain.”</li>
        <li><strong>Compute LWE Transformation</strong>: c(x)=a(x)⋅s(x) + e(x)</li>
        <li><strong>Apply Error Distribution</strong>: The small error polynomial e(x) is sampled from a zero-centered discrete Gaussian distribution (σ ≈ 4).</li>
        <li><strong>Apply Inverse NTT</strong>: Converts from NTT domain back to standard coefficient representation producing the final polynomial ciphertext.</li>
    </ul>

    <h3>2.3 DID & DID Document Construction</h3>
    <p>The process first converts a user’s personal attributes into a suitable polynomial form and adds a small Gaussian “noise” polynomial to mask the underlying data. It then performs the core Ring-LWE encryption and applies a Number-Theoretic Transform (NTT) to enable efficient polynomial operations and manage noise. A nonlinear tanh activation scrambles any remaining linear structure in the transformed coefficients before generating two cryptographic hash digests that together produce a unique token used as the DID suffix. Next, a JSON-LD DID Document is assembled—including the "id", the "verificationMethod", the "authentication" entry, and a "service" endpoint. Finally, this encrypted DID Document is written to a ledger-agnostic storage layer.</p>

    <h3>2.4 Signature Generation and verification Technical flow</h3>
    <p><strong>2.4.1 Signature generation</strong>: When creating a PQIE signature, we compute a single hash value from the encrypted DID data along with the DID string itself. This hash becomes the “digest” that we will sign. To produce the signature, the signer’s secret key and a fresh small random polynomial “y” are used together.</p>
    <p><strong>2.4.2 Verification</strong>: Resolvers retrieve the encrypted DID Document, decrypt it with the public key, and verify the signature before releasing attributes. In the Ring-LWE KEM Decapsulation step, the resolver uses the DID’s stored public key pk to recover the shared secret.</p>

    <h3>2.5 Signing, Encryption & Storage</h3>
    <p>Starting from a nonce or random seed N, the system first performs an LWE-based randomized signature over the newly generated DID string. Once the DID is signed, the process builds a full JSON-LD DID Document. After assembling the DID Document in JSON form, a ledger-write operation occurs—writing the DID and its encrypted document onto the chosen blockchain via the ledger-agnostic interface, ensuring immutability.</p>
</section>
<section>
        <h2>Method Specific Identifier</h2>
        <p>The namestring that shall identify this DID method is: <code>pqie</code></p>
        <p>A DID that uses this method MUST begin with the prefix: <code>did:pqie</code></p>
        <p>The method specific identifier is composed of a primary-hash, secondary-hash, and entropy-suffix.</p>
        <pre><code>pqie-did = "did:pqie:" pqie-specific-idstring
pqie-specific-idstring = pqie-identifier
pqie-identifier = 8HEXDIG ":" 8HEXDIG ":" 8HEXDIG</code></pre>
        <h3>Example</h3>
        <pre><code>did:pqie:5135e697:8b7ecf94:a3f21bc0
did:pqie:a1b2c3d4:e5f6g7h8:i9j0k1l2
did:pqie:12345678:90abcdef:1234abcd</code></pre>
    </section>

    <section>
        <h2>DID Document</h2>
        <p>Example of DID document of regular identity:</p>
        <pre><code>{
  "@context": ["https://www.w3.org/ns/did/v1", "https://pqie.network/ns/did/v1"],
  "id": "did:pqie:5135e697:8b7ecf94:a3f21bc0",
  "verificationMethod": [{
    "id": "did:pqie:5135e697:8b7ecf94:a3f21bc0#key-1",
    "type": "PQIE-RingLWE2024",
    "controller": "did:pqie:5135e697:8b7ecf94:a3f21bc0",
    "publicKeyLattice": "AAAA...",
    "latticeParams": { "n": 512, "q": 24593 }
  }],
  "authentication": ["did:pqie:5135e697:8b7ecf94:a3f21bc0#key-1"]
}</code></pre>
    </section>

    <section>
    <h2>JSON-LD Context</h2>
    <p>The pqie did method uses additional JSON-LD types.</p>
    <p>The JSON-LD vocabulary is stored in:</p>
    <ul>
        <li><code>https://pqie.network/ns/did/v1#</code> <br>Context contains <code>publicKeyLattice</code> (Operational key) and <code>latticeParams</code> types.</li>
        <li><code>https://schema.iden3.io/core/jsonld/iden3proofs.jsonld</code> <br>Context contains lattice signature proofs types and some specific credential statuses types used with pqie based identities.</li>
    </ul>
</section>

    <section>
    <h2>Basic operations</h2>
    <p>Each identity has a unique DID that is determined by the initial identity state (derived from the base identity attributes). This identifier is called the Genesis ID, under which the initial claims and verification methods are bound.</p>

    <h3>Create</h3>
    <p>The creation of the identity (<code>did:pqie</code>) begins by generating a base Kyber-1024 keypair ($n=512$, $q=24593$). For identity attribute binding, the user's underlying claims are lifted into a Ring-LWE polynomial with injected Gaussian noise (&sigma;=4.0). <br>
    The Genesis ID (<code>pqie-identifier</code>) is deterministically constructed by taking the <code>sha3_512</code> and <code>blake2b</code> hashes of the public key lattice and appending a 4-byte random entropy suffix to prevent collisions. <br>
    The Genesis Claims, including the raw public key and metadata representation, are encrypted via a Ring-LWE Key Encapsulation Mechanism (KEM) and AES-GCM into a secure payload known as a Digital Envelope. This Envelope is pinned to decentralized storage (e.g., IPFS), and its resulting CID is anchored directly on the ledger (e.g., via an Indy NYM transaction or Ethereum smart contract).</p>

    <h3>State transition (Update)</h3>
    <p>Adding new keys, rotating existing keys, or updating the encrypted claims requires governed state transitions. The state transition is executed by creating a new Digital Envelope reflecting the updated DID Document. <br>
    To validate the transition without exposing the underlying private keys or plaintext documents, the controller generates a Post-Quantum Lattice Signature (e.g., using Dilithium) over the new Digital Envelope's IPFS CID and the previous state root. This signature is verified by the ledger node (or smart contract) before accepting the state update, ensuring only the exact mathematical owner can transition the identity state.</p>

    <h3>Deactivate</h3>
    <p>When the identity owner explicitly revokes their operational Kyber-1024 keys or an assigned governing authority issues a revocation constraint (in the case of on-chain KYC identities), the identity is considered deactivated. A signed lattice transaction is submitted to the registry, appending a revocation flag. A deactivated identity can no longer generate valid Token structures, create proofs, or execute state transitions.</p>

    <h3>Type of identity</h3>
    <ul>
        <li><strong>Regular</strong> - identity generated by the user or organization off-chain, leveraging IPFS and independent anchors for mapping state.</li>
        <li><strong>On-chain identity</strong> - identity created and managed directly by a smart contract or authority. This type of identity can behave as an on-chain issuer, allowing any dAPP to issue credentials to its users in a trustless manner. It contains an additional verification method (<code>EcdsaSecp256k1RecoveryMethod2020</code>) that relies on the EVM address from which the identity was originally created.</li>
    </ul>

    <h3>Resolve</h3>
    <p>Abstract algorithm for resolving (read operation).</p>
    <p>Contract address for resolving the did (indy main/test networks): <code>0xPQIEREGISTRY000000000000000000</code></p>
    <p>PQIE did driver accepts DID in URI format. Currently, we support three URI formats:</p>
    <ul>
        <li><code>did:pqie:5135e697:8b7ecf94:a3f21bc0</code></li>
        <li><code>did:pqie:5135e697:8b7ecf94:a3f21bc0?state=&lt;hex_of_state&gt;</code></li>
        <li><code>did:pqie:5135e697:8b7ecf94:a3f21bc0?gist=&lt;hex_of_gist_state&gt;</code></li>
    </ul>
    <p>Each of these formats has a different read algorithm. But they all have a certain common logic of presentation.</p>
    
    <p>Common steps for all formats of DID:</p>
    <ol>
        <li>1.1 Get a method from DID (pqie).</li>
        <li>1.2 Get a blockchain name from DID if applicable.</li>
        <li>1.3 Get chain ID from DID.</li>
        <li>1.4 Verify data that was encoded on the identification.</li>
        <li>1.5 Find resolver by pair of chain name and blockchain id.</li>
    </ol>
    <p><strong>Step 5:</strong></p>
    <ol>
        <li>5.1 Read operation for the simple format of DID. This format means that the resolver should read the latest information about ID and GIST from the contract.</li>
        <ul>
            <li>5.1.1 Call getGISTRoot from the contract to get the latest GIST state.</li>
            <li>5.1.2 Call getGISTRootInfo with GIST from the step above to get the latest information about GIST.</li>
            <li>5.1.3 Call getStateInfoById with the user ID to get the latest information about the user’s state. If it does not exist return an empty object</li>
        </ul>
        <li>5.2 <code>did...#state=&lt;state&gt;</code> Resolve DID document by committed state. In some cases, we should get historical DID to validate the information that was replaced at the current time.</li>
        <ul>
            <li>5.2.1 Call getStateInfoByState from the contract to get information about the user’s state by state.</li>
            <li>5.2.2 Verify that this state is the user’s state.</li>
        </ul>
        <li>5.3 <code>did...#gist=&lt;state&gt;</code> Resolve state by gist state. Identities can exist under a global state for increased security and anonymity.</li>
        <ul>
            <li>5.3.1 Call getGISTProofByRoot with GIST root (key) and users ID (value), for get exist or not exist proof.</li>
            <li>5.3.2 Call getGISTRootInfo with root from the step above to get GIST information.</li>
            <li>5.3.3 If the proof has exists = true, execute the next state. If exists = false return information only about GIST state.</li>
            <li>5.3.4 Call getStateInfoByState with the value from proof to return information about the user’s state.</li>
        </ul>
    </ol>
    <p>JSON result description: <a href="https://pqie.network/ns/did/v1#state-info">https://pqie.network/ns/did/v1#state-info</a></p>
    
    <p>Build representation document: After fetching the gist and the user’s state it is possible to build a representation document.</p>
    <ul>
        <li>6.1 Create PQIEStateInfo2024 verification method : 
            <ul>
                <li>6.1.1 struct { id type stateContractAddress published latest global } </li>
                <li>6.1.2 In the latest field, put information about the user’s state. In the global field, put information about the GIST state.</li>
                <li>6.1.3 Fill id filed in the following format &lt;did&gt;#state=&lt;requested_state|latest_state&gt;. requested_state - use the state from the request if the request had #state=... latest_state - use the state from the resolver response.</li>
                <li>6.1.4 Add PQIEStateInfo2024 type to type field.</li>
                <li>6.1.5 Fill stateContractAddress in the following format &lt;chain_id&gt;:&lt;resolver_contract&gt;.</li>
                <li>6.1.6 Set true in published if the user’s state was been published to the smart contract.</li>
                <li>6.1.7 Create an array authentication and put the struct from step 6.1 in this array.</li>
                <li>6.1.8 Put the array authentication to didDocument. Also, add <code>@context: ["https://www.w3.org/ns/did/v1", "https://pqie.network/ns/did/v1"]</code> to this didDocument, add object to this array</li>
            </ul>
        </li>
        <li>6.2 Add optional EcdsaSecp256k1RecoveryMethod2020 for ethereum controlled identities.
            <ul>
                <li>6.2.1 Check if identity is ethereum based.</li>
                <li>6.2.2 If it is an ethereum controlled identity add EcdsaSecp256k1RecoveryMethod2020 following the corresponding specification</li>
            </ul>
        </li>
        <li>6.9 Build representation:<br>
          <pre><code>{
  "@context": ["https://w3id.org/did-resolution/v1"],
  "didDocument": {},
  "didResolutionMetadata": {},
  "didDocumentMetadata": {}
}</code></pre>
        </li>
    </ul>
</section>

    <section>
    <h2>Security and Privacy Considerations</h2>
    <h3>Data Forgery Prevention</h3>
    <p>Our DID method prevents forgery and falsification through the usage of Post-Quantum Lattice Signatures (Dilithium) and Ring-LWE Digital Envelopes, such that only the exact mathematical identity owner can issue or present DID-linked credentials. The identity owner can choose to A) Only issue verifiable claims locked under their lattice public key or; B) Issue access tokens utilizing the homomorphic properties of Ring-LWE where specific metadata evaluations are computed directly over the ciphertexts without leaking the raw data. The controller securely signs data transitions, protecting against forgery even against cryptanalytically relevant quantum computers (CRQCs).</p>

    <h3>Eavesdropping attacks</h3>
    <p>Eavesdropping attacks need to be mitigated by the usage of a secure communication channel (secured with TLS or similar means), since we use a message-based communication protocol that is not natively encrypted in transit layers. However, PQIE's "Encrypted-by-Default" architecture wraps the initial and updated DID Document structures in a Digital Envelope (AES-GCM locked by Ring-LWE KEM). As a result, network listeners and passive ledger observers only ever intercept an encrypted IPFS CID payload, providing a secondary robust defense-in-depth against data scraping.</p>

    <h3>Cryptographic Agility</h3>
    <p>The <code>did:pqie</code> method leverages modern Ring-LWE lattice cryptography. The initial standard uses Kyber-1024 parameters ($n=512$, $q=24593$) for key encapsulation/encryption, mapping variables closely to NIST’s FIPS 203. For signature authentication, parameter sets corresponding to Dilithium (FIPS 204) are required to sign the Digital Envelope states. In the future, other post-quantum parameter sets can be dynamically encoded using the <code>latticeParams</code> object within the DID Document’s verification method, providing immediate forward compatibility as post-quantum standardized extensions evolve.</p>

    <h3>Keep DID Keys safe</h3>
    <p>The DID method inherently includes support for comprehensive key rotation semantics; however, if the core Kyber lattice secret key ($s$) is compromised, an attacker may generate valid post-quantum signatures to rotate operational keys and thereby hijack the identity state mappings. Controllers SHOULD rigorously store their lattice private keys in hardware-backed security modules (HSM) or mathematically robust Trusted Execution Environments (TEE).</p>

    <h3>Keep personal data safe</h3>
    <p>The syntax and construction of the <code>did:pqie</code> DID and its universally distributed Document helps to ensure that no Personally Identifiable Information (PII) or personal data is exposed over the public network layer:</p>
    <ul>
        <li><strong>Zero On-Chain PII</strong>: Raw PII is NEVER stored directly on the ledger architecture. All persistent data is stored off-chain on IPFS strictly encapsulated within a Ring-LWE Digital Envelope.</li>
        <li><strong>Resistant Identifiers</strong>: The `pqie-identifier` utilizes sequential dual-hashing (`sha3_512` followed by `blake2b`), fundamentally preventing any algorithmic reverse-engineering of the underlying attributes.</li>
        <li><strong>Homomorphic Noise Injection</strong>: When lifting attributes to the polynomial mapping prior to encryption, discrete Gaussian noise (&sigma;=4.0) is inherently added. This guarantees the derived cyphertexts are computationally indistinguishable from uniform random arrays.</li>
    </ul>

    <h3>Additional Recommendations</h3>
    <p>Implementers are strongly encouraged to review the following:</p>
    <ul>
        <li><a href="https://w3c.github.io/did-imp-guide/#privacy-considerations">Privacy Considerations in DID Implementation Guide</a></li>
        <li><a href="https://www.w3.org/TR/did-core/#privacy-considerations">Privacy Considerations in DID Core</a></li>
    </ul>
</section>

<section>
    <h2>3. Future Scope: PQIE in Web 3.0</h2>
    <p>Because PQIE is ledger-agnostic, it can plug into diverse Web 3.0 runtimes. DeFi platforms can embed quantum-safe KYC proofs, healthcare networks can share encrypted patient IDs across hospitals, supply-chain consortia can bind tamper-proof product DIDs to digital twins, and metaverse environments can issue long-lived, privacy-preserving avatar credentials.</p>
</section>
<section>
    <h2>4. Ring-LWE Security Analysis</h2>
    <p>Ring-LWE hardness is reducible to the worst-case Shortest Vector Problem (SVP) in ideal lattices. We adopt the Kyber-1024 core parameters for encryption compatibility, with modulus q = 3329 and polynomial degree n = 256, but expand to n = 512 for signature tightness. The ciphertext modulus is selected as a product of two 14-bit primes, enabling RNS decomposition that aligns with AVX2 vector lanes. Table 2 compares our security margins with Dilithium-III and Falcon-512.</p>
    <table border="1" cellpadding="5" cellspacing="0" style="margin-top: 1rem; border-collapse: collapse; font-size: 0.9rem;">
        <tr><th>Scheme</th><th>n</th><th>q</th><th>Quantum Bit-Security</th></tr>
        <tr><td><strong>PQIE-Enc</strong></td><td>512</td><td>24577</td><td>256</td></tr>
        <tr><td><strong>Dilithium-III</strong></td><td>256</td><td>8380417</td><td>192</td></tr>
        <tr><td><strong>Falcon-512</strong></td><td>512</td><td>12289</td><td>128</td></tr>
    </table>

    <br>
    <h3>4.1 Trapdoor Hardness & Post-Quantum Resilience</h3>
    <p>The core security assumption underpinning PQIE is the <strong>Ring Learning With Errors (Ring-LWE)</strong> problem over cyclotomic rings $\mathbb{Z}_p[x]/(x^n + 1)$. Recovering the exact secret polynomial $s$ from a generated public sample $b = a \cdot s + e \pmod q$ is mathematically reducible to the Shortest Vector Problem (SVP) in a family of ideal lattices.</p>
    <p>This specific construction withstands not only the best known classical lattice reduction attacks (e.g., BKZ algorithm parameters), but is definitively immune to <strong>Quantum Fourier-Sampling Attacks</strong> (such as Shor's algorithm, which easily factors RSA and solves Discrete Logarithms for Elliptic Curves).</p>

    <h3>4.2 Non-Linear Operations & Side-Channel Mitigation</h3>
    <p>To prevent side-channel leakage across consecutive protocol sessions, PQIE injects specific non-linear distortions during polynomial mapping:</p>
    <ul>
        <li><strong>Number-Theoretic Transform (NTT)</strong>: Coefficients undergo high-speed $O(n \log n)$ conversion to the NTT domain to enable constant-time convolution, mitigating timing-based side channels.</li>
        <li><strong>tanh Activation Scrambling</strong>: Before noise addition, a pointwise $\tanh$ function is deterministically applied to each coefficient. This disrupts linear interpolation patterns in NTT outputs that may otherwise leak the geometry of $s$ or $e$ over multiple signature nonces.</li>
    </ul>

    <h3>4.3 Error Generation and Homomorphic Filtering</h3>
    <p>The error polynomial $e(x)$ is meticulously sampled from a zero-centered discrete Gaussian distribution ($\sigma \approx 4.0$). Each individual coefficient $e_i$ is bound heavily between $(-5 \dots +5)$, mathematically ensuring that the initial cryptographic noise remains minimal.</p>
    <p>However, during active sessions (especially regarding Verifiable Credentials that rely heavily on zero-knowledge evaluation over ciphertexts), noise inherently grows. PQIE applies an aggressive <strong>Homomorphic Noise Filter</strong>:</p>
    <ul>
        <li>After roughly 128 cryptographic operations, for every polynomial coefficient $c_i$, we compute $c_i' = (c_i \pmod{q/4})$ and set the new operating modulus $q \leftarrow q/4$.</li>
        <li>This step acts as a refreshing mechanism, aggressively keeping the encrypted DID payload size statically beneath 2 kB, minimizing overall ledger storage costs without ever exposing underlying data or weakening the lattice bound.</li>
    </ul>
</section>

</body>

</html>